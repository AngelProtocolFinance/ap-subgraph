// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class User extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type User must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("User", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): User | null {
    return changetype<User | null>(
      store.get_in_block("User", id.toHexString())
    );
  }

  static load(id: Bytes): User | null {
    return changetype<User | null>(store.get("User", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get multiSigs(): MultiSigOwnerLoader {
    return new MultiSigOwnerLoader(
      "User",
      this.get("id")!.toString(),
      "multiSigs"
    );
  }

  get applicationProposals(): ApplicationProposalLoader {
    return new ApplicationProposalLoader(
      "User",
      this.get("id")!.toString(),
      "applicationProposals"
    );
  }

  get tokenAllowances(): EndowmentTokenAllowanceSpenderLoader {
    return new EndowmentTokenAllowanceSpenderLoader(
      "User",
      this.get("id")!.toString(),
      "tokenAllowances"
    );
  }

  get beneficiaryOf(): ClosingBeneficiaryLoader {
    return new ClosingBeneficiaryLoader(
      "User",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "beneficiaryOf"
    );
  }
}

export class MultiSig extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MultiSig entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type MultiSig must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MultiSig", id.toString(), this);
    }
  }

  static loadInBlock(id: string): MultiSig | null {
    return changetype<MultiSig | null>(store.get_in_block("MultiSig", id));
  }

  static load(id: string): MultiSig | null {
    return changetype<MultiSig | null>(store.get("MultiSig", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get owners(): MultiSigOwnerLoader {
    return new MultiSigOwnerLoader(
      "MultiSig",
      this.get("id")!.toString(),
      "owners"
    );
  }

  get transactions(): MultiSigTransactionLoader {
    return new MultiSigTransactionLoader(
      "MultiSig",
      this.get("id")!.toString(),
      "transactions"
    );
  }

  get transactionExpiry(): BigInt {
    let value = this.get("transactionExpiry");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set transactionExpiry(value: BigInt) {
    this.set("transactionExpiry", Value.fromBigInt(value));
  }

  get requireExecution(): boolean {
    let value = this.get("requireExecution");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set requireExecution(value: boolean) {
    this.set("requireExecution", Value.fromBoolean(value));
  }

  get approvalsRequired(): BigInt {
    let value = this.get("approvalsRequired");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set approvalsRequired(value: BigInt) {
    this.set("approvalsRequired", Value.fromBigInt(value));
  }
}

export class MultiSigOwner extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MultiSigOwner entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type MultiSigOwner must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MultiSigOwner", id.toString(), this);
    }
  }

  static loadInBlock(id: string): MultiSigOwner | null {
    return changetype<MultiSigOwner | null>(
      store.get_in_block("MultiSigOwner", id)
    );
  }

  static load(id: string): MultiSigOwner | null {
    return changetype<MultiSigOwner | null>(store.get("MultiSigOwner", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get multiSig(): string {
    let value = this.get("multiSig");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set multiSig(value: string) {
    this.set("multiSig", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get active(): boolean {
    let value = this.get("active");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set active(value: boolean) {
    this.set("active", Value.fromBoolean(value));
  }
}

export class MultiSigTransaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MultiSigTransaction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type MultiSigTransaction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MultiSigTransaction", id.toString(), this);
    }
  }

  static loadInBlock(id: string): MultiSigTransaction | null {
    return changetype<MultiSigTransaction | null>(
      store.get_in_block("MultiSigTransaction", id)
    );
  }

  static load(id: string): MultiSigTransaction | null {
    return changetype<MultiSigTransaction | null>(
      store.get("MultiSigTransaction", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transactionId(): BigInt {
    let value = this.get("transactionId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set transactionId(value: BigInt) {
    this.set("transactionId", Value.fromBigInt(value));
  }

  get multiSig(): string {
    let value = this.get("multiSig");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set multiSig(value: string) {
    this.set("multiSig", Value.fromString(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }

  get executed(): boolean {
    let value = this.get("executed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set executed(value: boolean) {
    this.set("executed", Value.fromBoolean(value));
  }

  get expiry(): BigInt {
    let value = this.get("expiry");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set expiry(value: BigInt) {
    this.set("expiry", Value.fromBigInt(value));
  }

  get metadata(): Bytes {
    let value = this.get("metadata");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set metadata(value: Bytes) {
    this.set("metadata", Value.fromBytes(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get confirmations(): TransactionConfirmationLoader {
    return new TransactionConfirmationLoader(
      "MultiSigTransaction",
      this.get("id")!.toString(),
      "confirmations"
    );
  }
}

export class TransactionConfirmation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TransactionConfirmation entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TransactionConfirmation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TransactionConfirmation", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TransactionConfirmation | null {
    return changetype<TransactionConfirmation | null>(
      store.get_in_block("TransactionConfirmation", id)
    );
  }

  static load(id: string): TransactionConfirmation | null {
    return changetype<TransactionConfirmation | null>(
      store.get("TransactionConfirmation", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get confirmed(): boolean {
    let value = this.get("confirmed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set confirmed(value: boolean) {
    this.set("confirmed", Value.fromBoolean(value));
  }
}

export class ApplicationProposal extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ApplicationProposal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ApplicationProposal must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ApplicationProposal", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ApplicationProposal | null {
    return changetype<ApplicationProposal | null>(
      store.get_in_block("ApplicationProposal", id)
    );
  }

  static load(id: string): ApplicationProposal | null {
    return changetype<ApplicationProposal | null>(
      store.get("ApplicationProposal", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get executed(): boolean {
    let value = this.get("executed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set executed(value: boolean) {
    this.set("executed", Value.fromBoolean(value));
  }

  get charityName(): string {
    let value = this.get("charityName");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set charityName(value: string) {
    this.set("charityName", Value.fromString(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }

  get expiry(): BigInt {
    let value = this.get("expiry");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set expiry(value: BigInt) {
    this.set("expiry", Value.fromBigInt(value));
  }

  get metadata(): Bytes {
    let value = this.get("metadata");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set metadata(value: Bytes) {
    this.set("metadata", Value.fromBytes(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get confirmations(): ApplicationConfirmationLoader {
    return new ApplicationConfirmationLoader(
      "ApplicationProposal",
      this.get("id")!.toString(),
      "confirmations"
    );
  }
}

export class ApplicationConfirmation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ApplicationConfirmation entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ApplicationConfirmation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ApplicationConfirmation", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ApplicationConfirmation | null {
    return changetype<ApplicationConfirmation | null>(
      store.get_in_block("ApplicationConfirmation", id)
    );
  }

  static load(id: string): ApplicationConfirmation | null {
    return changetype<ApplicationConfirmation | null>(
      store.get("ApplicationConfirmation", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get confirmed(): boolean {
    let value = this.get("confirmed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set confirmed(value: boolean) {
    this.set("confirmed", Value.fromBoolean(value));
  }
}

export class Endowment extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Endowment entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Endowment must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Endowment", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Endowment | null {
    return changetype<Endowment | null>(store.get_in_block("Endowment", id));
  }

  static load(id: string): Endowment | null {
    return changetype<Endowment | null>(store.get("Endowment", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get endowmentType(): string {
    let value = this.get("endowmentType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowmentType(value: string) {
    this.set("endowmentType", Value.fromString(value));
  }

  get closingBeneficiary(): Bytes | null {
    let value = this.get("closingBeneficiary");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set closingBeneficiary(value: Bytes | null) {
    if (!value) {
      this.unset("closingBeneficiary");
    } else {
      this.set("closingBeneficiary", Value.fromBytes(<Bytes>value));
    }
  }

  get beneficiaryOf(): ClosingBeneficiaryLoader {
    return new ClosingBeneficiaryLoader(
      "Endowment",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "beneficiaryOf"
    );
  }

  get balancesLocked(): EndowmentTokenLockedLoader {
    return new EndowmentTokenLockedLoader(
      "Endowment",
      this.get("id")!.toString(),
      "balancesLocked"
    );
  }

  get balancesLiquid(): EndowmentTokenLiquidLoader {
    return new EndowmentTokenLiquidLoader(
      "Endowment",
      this.get("id")!.toString(),
      "balancesLiquid"
    );
  }

  get deposits(): EndowmentDepositTransactionLoader {
    return new EndowmentDepositTransactionLoader(
      "Endowment",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "deposits"
    );
  }

  get withdrawals(): EndowmentWithdrawTransactionLoader {
    return new EndowmentWithdrawTransactionLoader(
      "Endowment",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "withdrawals"
    );
  }

  get swaps(): EndowmentSwapTransactionLoader {
    return new EndowmentSwapTransactionLoader(
      "Endowment",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "swaps"
    );
  }
}

export class ClosingBeneficiary extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ClosingBeneficiary entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ClosingBeneficiary must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ClosingBeneficiary", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): ClosingBeneficiary | null {
    return changetype<ClosingBeneficiary | null>(
      store.get_in_block("ClosingBeneficiary", id.toHexString())
    );
  }

  static load(id: Bytes): ClosingBeneficiary | null {
    return changetype<ClosingBeneficiary | null>(
      store.get("ClosingBeneficiary", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get closingEndowment(): EndowmentLoader {
    return new EndowmentLoader(
      "ClosingBeneficiary",
      this.get("id")!.toString(),
      "closingEndowment"
    );
  }

  get beneficiaryEndowment(): string | null {
    let value = this.get("beneficiaryEndowment");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set beneficiaryEndowment(value: string | null) {
    if (!value) {
      this.unset("beneficiaryEndowment");
    } else {
      this.set("beneficiaryEndowment", Value.fromString(<string>value));
    }
  }

  get beneficiaryWallet(): Bytes | null {
    let value = this.get("beneficiaryWallet");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set beneficiaryWallet(value: Bytes | null) {
    if (!value) {
      this.unset("beneficiaryWallet");
    } else {
      this.set("beneficiaryWallet", Value.fromBytes(<Bytes>value));
    }
  }
}

export class EndowmentTokenLocked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save EndowmentTokenLocked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EndowmentTokenLocked must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EndowmentTokenLocked", id.toString(), this);
    }
  }

  static loadInBlock(id: string): EndowmentTokenLocked | null {
    return changetype<EndowmentTokenLocked | null>(
      store.get_in_block("EndowmentTokenLocked", id)
    );
  }

  static load(id: string): EndowmentTokenLocked | null {
    return changetype<EndowmentTokenLocked | null>(
      store.get("EndowmentTokenLocked", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get endowment(): string {
    let value = this.get("endowment");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowment(value: string) {
    this.set("endowment", Value.fromString(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class EndowmentTokenLiquid extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save EndowmentTokenLiquid entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EndowmentTokenLiquid must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EndowmentTokenLiquid", id.toString(), this);
    }
  }

  static loadInBlock(id: string): EndowmentTokenLiquid | null {
    return changetype<EndowmentTokenLiquid | null>(
      store.get_in_block("EndowmentTokenLiquid", id)
    );
  }

  static load(id: string): EndowmentTokenLiquid | null {
    return changetype<EndowmentTokenLiquid | null>(
      store.get("EndowmentTokenLiquid", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get endowment(): string {
    let value = this.get("endowment");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowment(value: string) {
    this.set("endowment", Value.fromString(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get allowanceOutstanding(): BigInt {
    let value = this.get("allowanceOutstanding");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set allowanceOutstanding(value: BigInt) {
    this.set("allowanceOutstanding", Value.fromBigInt(value));
  }

  get allowanceSpenders(): EndowmentTokenAllowanceSpenderLoader {
    return new EndowmentTokenAllowanceSpenderLoader(
      "EndowmentTokenLiquid",
      this.get("id")!.toString(),
      "allowanceSpenders"
    );
  }
}

export class EndowmentTokenAllowanceSpender extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save EndowmentTokenAllowanceSpender entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EndowmentTokenAllowanceSpender must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EndowmentTokenAllowanceSpender", id.toString(), this);
    }
  }

  static loadInBlock(id: string): EndowmentTokenAllowanceSpender | null {
    return changetype<EndowmentTokenAllowanceSpender | null>(
      store.get_in_block("EndowmentTokenAllowanceSpender", id)
    );
  }

  static load(id: string): EndowmentTokenAllowanceSpender | null {
    return changetype<EndowmentTokenAllowanceSpender | null>(
      store.get("EndowmentTokenAllowanceSpender", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class EndowmentDepositTransaction extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save EndowmentDepositTransaction entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type EndowmentDepositTransaction must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set(
        "EndowmentDepositTransaction",
        id.toBytes().toHexString(),
        this
      );
    }
  }

  static loadInBlock(id: Bytes): EndowmentDepositTransaction | null {
    return changetype<EndowmentDepositTransaction | null>(
      store.get_in_block("EndowmentDepositTransaction", id.toHexString())
    );
  }

  static load(id: Bytes): EndowmentDepositTransaction | null {
    return changetype<EndowmentDepositTransaction | null>(
      store.get("EndowmentDepositTransaction", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get endowment(): string {
    let value = this.get("endowment");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowment(value: string) {
    this.set("endowment", Value.fromString(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amountLocked(): BigInt {
    let value = this.get("amountLocked");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountLocked(value: BigInt) {
    this.set("amountLocked", Value.fromBigInt(value));
  }

  get amountLiquid(): BigInt {
    let value = this.get("amountLiquid");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountLiquid(value: BigInt) {
    this.set("amountLiquid", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class EndowmentWithdrawTransaction extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save EndowmentWithdrawTransaction entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type EndowmentWithdrawTransaction must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set(
        "EndowmentWithdrawTransaction",
        id.toBytes().toHexString(),
        this
      );
    }
  }

  static loadInBlock(id: Bytes): EndowmentWithdrawTransaction | null {
    return changetype<EndowmentWithdrawTransaction | null>(
      store.get_in_block("EndowmentWithdrawTransaction", id.toHexString())
    );
  }

  static load(id: Bytes): EndowmentWithdrawTransaction | null {
    return changetype<EndowmentWithdrawTransaction | null>(
      store.get("EndowmentWithdrawTransaction", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get endowment(): string {
    let value = this.get("endowment");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowment(value: string) {
    this.set("endowment", Value.fromString(value));
  }

  get accountType(): string {
    let value = this.get("accountType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set accountType(value: string) {
    this.set("accountType", Value.fromString(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get beneficiaryEndowId(): i32 {
    let value = this.get("beneficiaryEndowId");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set beneficiaryEndowId(value: i32) {
    this.set("beneficiaryEndowId", Value.fromI32(value));
  }

  get beneficiaryAddr(): Bytes | null {
    let value = this.get("beneficiaryAddr");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set beneficiaryAddr(value: Bytes | null) {
    if (!value) {
      this.unset("beneficiaryAddr");
    } else {
      this.set("beneficiaryAddr", Value.fromBytes(<Bytes>value));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class EndowmentSwapTransaction extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save EndowmentSwapTransaction entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type EndowmentSwapTransaction must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EndowmentSwapTransaction", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): EndowmentSwapTransaction | null {
    return changetype<EndowmentSwapTransaction | null>(
      store.get_in_block("EndowmentSwapTransaction", id.toHexString())
    );
  }

  static load(id: Bytes): EndowmentSwapTransaction | null {
    return changetype<EndowmentSwapTransaction | null>(
      store.get("EndowmentSwapTransaction", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get endowment(): string {
    let value = this.get("endowment");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowment(value: string) {
    this.set("endowment", Value.fromString(value));
  }

  get accountType(): string {
    let value = this.get("accountType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set accountType(value: string) {
    this.set("accountType", Value.fromString(value));
  }

  get tokenIn(): Bytes {
    let value = this.get("tokenIn");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tokenIn(value: Bytes) {
    this.set("tokenIn", Value.fromBytes(value));
  }

  get amountIn(): BigInt {
    let value = this.get("amountIn");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountIn(value: BigInt) {
    this.set("amountIn", Value.fromBigInt(value));
  }

  get tokenOut(): Bytes {
    let value = this.get("tokenOut");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tokenOut(value: Bytes) {
    this.set("tokenOut", Value.fromBytes(value));
  }

  get amountOut(): BigInt {
    let value = this.get("amountOut");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountOut(value: BigInt) {
    this.set("amountOut", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Strategy extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Strategy entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Strategy must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Strategy", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Strategy | null {
    return changetype<Strategy | null>(
      store.get_in_block("Strategy", id.toHexString())
    );
  }

  static load(id: Bytes): Strategy | null {
    return changetype<Strategy | null>(store.get("Strategy", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get network(): string {
    let value = this.get("network");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set network(value: string) {
    this.set("network", Value.fromString(value));
  }

  get state(): string {
    let value = this.get("state");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set state(value: string) {
    this.set("state", Value.fromString(value));
  }

  get vaultLocked(): VaultLoader {
    return new VaultLoader(
      "Strategy",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "vaultLocked"
    );
  }

  get vaultLiquid(): VaultLoader {
    return new VaultLoader(
      "Strategy",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "vaultLiquid"
    );
  }
}

export class Vault extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Vault entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Vault must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Vault", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Vault | null {
    return changetype<Vault | null>(
      store.get_in_block("Vault", id.toHexString())
    );
  }

  static load(id: Bytes): Vault | null {
    return changetype<Vault | null>(store.get("Vault", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get type(): string {
    let value = this.get("type");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set type(value: string) {
    this.set("type", Value.fromString(value));
  }

  get strategy(): Bytes {
    let value = this.get("strategy");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set strategy(value: Bytes) {
    this.set("strategy", Value.fromBytes(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get yieldToken(): Bytes {
    let value = this.get("yieldToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set yieldToken(value: Bytes) {
    this.set("yieldToken", Value.fromBytes(value));
  }

  get totalShares(): BigInt {
    let value = this.get("totalShares");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalShares(value: BigInt) {
    this.set("totalShares", Value.fromBigInt(value));
  }

  get shares(): VaultShareLoader {
    return new VaultShareLoader("Vault", this.get("id")!.toString(), "shares");
  }
}

export class VaultShare extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save VaultShare entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VaultShare must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("VaultShare", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VaultShare | null {
    return changetype<VaultShare | null>(store.get_in_block("VaultShare", id));
  }

  static load(id: string): VaultShare | null {
    return changetype<VaultShare | null>(store.get("VaultShare", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get vault(): Bytes {
    let value = this.get("vault");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set vault(value: Bytes) {
    this.set("vault", Value.fromBytes(value));
  }

  get endowmentId(): string {
    let value = this.get("endowmentId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowmentId(value: string) {
    this.set("endowmentId", Value.fromString(value));
  }

  get deposited(): BigInt {
    let value = this.get("deposited");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set deposited(value: BigInt) {
    this.set("deposited", Value.fromBigInt(value));
  }

  get shares(): BigInt {
    let value = this.get("shares");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set shares(value: BigInt) {
    this.set("shares", Value.fromBigInt(value));
  }
}

export class MultiSigOwnerLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): MultiSigOwner[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<MultiSigOwner[]>(value);
  }
}

export class ApplicationProposalLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ApplicationProposal[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ApplicationProposal[]>(value);
  }
}

export class EndowmentTokenAllowanceSpenderLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentTokenAllowanceSpender[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentTokenAllowanceSpender[]>(value);
  }
}

export class ClosingBeneficiaryLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ClosingBeneficiary[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ClosingBeneficiary[]>(value);
  }
}

export class MultiSigTransactionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): MultiSigTransaction[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<MultiSigTransaction[]>(value);
  }
}

export class TransactionConfirmationLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TransactionConfirmation[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TransactionConfirmation[]>(value);
  }
}

export class ApplicationConfirmationLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ApplicationConfirmation[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ApplicationConfirmation[]>(value);
  }
}

export class EndowmentTokenLockedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentTokenLocked[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentTokenLocked[]>(value);
  }
}

export class EndowmentTokenLiquidLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentTokenLiquid[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentTokenLiquid[]>(value);
  }
}

export class EndowmentDepositTransactionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentDepositTransaction[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentDepositTransaction[]>(value);
  }
}

export class EndowmentWithdrawTransactionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentWithdrawTransaction[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentWithdrawTransaction[]>(value);
  }
}

export class EndowmentSwapTransactionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentSwapTransaction[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentSwapTransaction[]>(value);
  }
}

export class EndowmentLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Endowment[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Endowment[]>(value);
  }
}

export class VaultLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Vault[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Vault[]>(value);
  }
}

export class VaultShareLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): VaultShare[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<VaultShare[]>(value);
  }
}
