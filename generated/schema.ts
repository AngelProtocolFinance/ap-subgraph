// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class User extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type User must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("User", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): User | null {
    return changetype<User | null>(
      store.get_in_block("User", id.toHexString())
    );
  }

  static load(id: Bytes): User | null {
    return changetype<User | null>(store.get("User", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get multiSigs(): MultiSigOwnerLoader {
    return new MultiSigOwnerLoader(
      "User",
      this.get("id")!.toString(),
      "multiSigs"
    );
  }

  get applicationProposals(): ApplicationProposalLoader {
    return new ApplicationProposalLoader(
      "User",
      this.get("id")!.toString(),
      "applicationProposals"
    );
  }

  get tokenAllowances(): EndowmentTokenAllowanceSpenderLoader {
    return new EndowmentTokenAllowanceSpenderLoader(
      "User",
      this.get("id")!.toString(),
      "tokenAllowances"
    );
  }
}

export class MultiSig extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MultiSig entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type MultiSig must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MultiSig", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): MultiSig | null {
    return changetype<MultiSig | null>(
      store.get_in_block("MultiSig", id.toHexString())
    );
  }

  static load(id: Bytes): MultiSig | null {
    return changetype<MultiSig | null>(store.get("MultiSig", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get owners(): MultiSigOwnerLoader {
    return new MultiSigOwnerLoader(
      "MultiSig",
      this.get("id")!.toString(),
      "owners"
    );
  }

  get transactions(): MultiSigTransactionLoader {
    return new MultiSigTransactionLoader(
      "MultiSig",
      this.get("id")!.toString(),
      "transactions"
    );
  }

  get transactionExpiry(): BigInt {
    let value = this.get("transactionExpiry");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set transactionExpiry(value: BigInt) {
    this.set("transactionExpiry", Value.fromBigInt(value));
  }

  get requireExecution(): boolean {
    let value = this.get("requireExecution");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set requireExecution(value: boolean) {
    this.set("requireExecution", Value.fromBoolean(value));
  }

  get approvalsRequired(): BigInt {
    let value = this.get("approvalsRequired");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set approvalsRequired(value: BigInt) {
    this.set("approvalsRequired", Value.fromBigInt(value));
  }

  get multiSigType(): string {
    let value = this.get("multiSigType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set multiSigType(value: string) {
    this.set("multiSigType", Value.fromString(value));
  }
}

export class MultiSigOwner extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MultiSigOwner entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type MultiSigOwner must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MultiSigOwner", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): MultiSigOwner | null {
    return changetype<MultiSigOwner | null>(
      store.get_in_block("MultiSigOwner", id.toHexString())
    );
  }

  static load(id: Bytes): MultiSigOwner | null {
    return changetype<MultiSigOwner | null>(
      store.get("MultiSigOwner", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get multiSig(): Bytes {
    let value = this.get("multiSig");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set multiSig(value: Bytes) {
    this.set("multiSig", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }
}

export class MultiSigTransaction extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MultiSigTransaction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type MultiSigTransaction must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MultiSigTransaction", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): MultiSigTransaction | null {
    return changetype<MultiSigTransaction | null>(
      store.get_in_block("MultiSigTransaction", id.toHexString())
    );
  }

  static load(id: Bytes): MultiSigTransaction | null {
    return changetype<MultiSigTransaction | null>(
      store.get("MultiSigTransaction", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transactionId(): BigInt {
    let value = this.get("transactionId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set transactionId(value: BigInt) {
    this.set("transactionId", Value.fromBigInt(value));
  }

  get multiSig(): Bytes {
    let value = this.get("multiSig");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set multiSig(value: Bytes) {
    this.set("multiSig", Value.fromBytes(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }

  get executed(): boolean {
    let value = this.get("executed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set executed(value: boolean) {
    this.set("executed", Value.fromBoolean(value));
  }

  get expiry(): BigInt {
    let value = this.get("expiry");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set expiry(value: BigInt) {
    this.set("expiry", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get confirmations(): TransactionConfirmationLoader {
    return new TransactionConfirmationLoader(
      "MultiSigTransaction",
      this.get("id")!.toString(),
      "confirmations"
    );
  }
}

export class TransactionConfirmation extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TransactionConfirmation entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type TransactionConfirmation must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TransactionConfirmation", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): TransactionConfirmation | null {
    return changetype<TransactionConfirmation | null>(
      store.get_in_block("TransactionConfirmation", id.toHexString())
    );
  }

  static load(id: Bytes): TransactionConfirmation | null {
    return changetype<TransactionConfirmation | null>(
      store.get("TransactionConfirmation", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get confirmed(): boolean {
    let value = this.get("confirmed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set confirmed(value: boolean) {
    this.set("confirmed", Value.fromBoolean(value));
  }
}

export class ApplicationsMultiSig extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ApplicationsMultiSig entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ApplicationsMultiSig must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ApplicationsMultiSig", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): ApplicationsMultiSig | null {
    return changetype<ApplicationsMultiSig | null>(
      store.get_in_block("ApplicationsMultiSig", id.toHexString())
    );
  }

  static load(id: Bytes): ApplicationsMultiSig | null {
    return changetype<ApplicationsMultiSig | null>(
      store.get("ApplicationsMultiSig", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get proposals(): ApplicationProposalLoader {
    return new ApplicationProposalLoader(
      "ApplicationsMultiSig",
      this.get("id")!.toString(),
      "proposals"
    );
  }

  get seedSplitToLiquid(): BigInt {
    let value = this.get("seedSplitToLiquid");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set seedSplitToLiquid(value: BigInt) {
    this.set("seedSplitToLiquid", Value.fromBigInt(value));
  }

  get gasAmount(): BigInt {
    let value = this.get("gasAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set gasAmount(value: BigInt) {
    this.set("gasAmount", Value.fromBigInt(value));
  }

  get seedAsset(): Bytes {
    let value = this.get("seedAsset");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set seedAsset(value: Bytes) {
    this.set("seedAsset", Value.fromBytes(value));
  }

  get seedAmount(): BigInt {
    let value = this.get("seedAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set seedAmount(value: BigInt) {
    this.set("seedAmount", Value.fromBigInt(value));
  }
}

export class ApplicationProposal extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ApplicationProposal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ApplicationProposal must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ApplicationProposal", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ApplicationProposal | null {
    return changetype<ApplicationProposal | null>(
      store.get_in_block("ApplicationProposal", id)
    );
  }

  static load(id: string): ApplicationProposal | null {
    return changetype<ApplicationProposal | null>(
      store.get("ApplicationProposal", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get multiSig(): Bytes {
    let value = this.get("multiSig");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set multiSig(value: Bytes) {
    this.set("multiSig", Value.fromBytes(value));
  }

  get charityName(): string {
    let value = this.get("charityName");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set charityName(value: string) {
    this.set("charityName", Value.fromString(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }

  get executed(): boolean {
    let value = this.get("executed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set executed(value: boolean) {
    this.set("executed", Value.fromBoolean(value));
  }

  get expiry(): BigInt {
    let value = this.get("expiry");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set expiry(value: BigInt) {
    this.set("expiry", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get confirmations(): ApplicationConfirmationLoader {
    return new ApplicationConfirmationLoader(
      "ApplicationProposal",
      this.get("id")!.toString(),
      "confirmations"
    );
  }
}

export class ApplicationConfirmation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ApplicationConfirmation entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ApplicationConfirmation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ApplicationConfirmation", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ApplicationConfirmation | null {
    return changetype<ApplicationConfirmation | null>(
      store.get_in_block("ApplicationConfirmation", id)
    );
  }

  static load(id: string): ApplicationConfirmation | null {
    return changetype<ApplicationConfirmation | null>(
      store.get("ApplicationConfirmation", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get confirmed(): boolean {
    let value = this.get("confirmed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set confirmed(value: boolean) {
    this.set("confirmed", Value.fromBoolean(value));
  }
}

export class ContractInstantiated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractInstantiated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ContractInstantiated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractInstantiated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): ContractInstantiated | null {
    return changetype<ContractInstantiated | null>(
      store.get_in_block("ContractInstantiated", id.toHexString())
    );
  }

  static load(id: Bytes): ContractInstantiated | null {
    return changetype<ContractInstantiated | null>(
      store.get("ContractInstantiated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get instantiation(): Bytes {
    let value = this.get("instantiation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set instantiation(value: Bytes) {
    this.set("instantiation", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ImplementationUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ImplementationUpdated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ImplementationUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ImplementationUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): ImplementationUpdated | null {
    return changetype<ImplementationUpdated | null>(
      store.get_in_block("ImplementationUpdated", id.toHexString())
    );
  }

  static load(id: Bytes): ImplementationUpdated | null {
    return changetype<ImplementationUpdated | null>(
      store.get("ImplementationUpdated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get implementationAddress(): Bytes {
    let value = this.get("implementationAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set implementationAddress(value: Bytes) {
    this.set("implementationAddress", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class EndowmentMultiSigFactoryOwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save EndowmentMultiSigFactoryOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type EndowmentMultiSigFactoryOwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set(
        "EndowmentMultiSigFactoryOwnershipTransferred",
        id.toBytes().toHexString(),
        this
      );
    }
  }

  static loadInBlock(
    id: Bytes
  ): EndowmentMultiSigFactoryOwnershipTransferred | null {
    return changetype<EndowmentMultiSigFactoryOwnershipTransferred | null>(
      store.get_in_block(
        "EndowmentMultiSigFactoryOwnershipTransferred",
        id.toHexString()
      )
    );
  }

  static load(id: Bytes): EndowmentMultiSigFactoryOwnershipTransferred | null {
    return changetype<EndowmentMultiSigFactoryOwnershipTransferred | null>(
      store.get(
        "EndowmentMultiSigFactoryOwnershipTransferred",
        id.toHexString()
      )
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ProxyAdminUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProxyAdminUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ProxyAdminUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ProxyAdminUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): ProxyAdminUpdated | null {
    return changetype<ProxyAdminUpdated | null>(
      store.get_in_block("ProxyAdminUpdated", id.toHexString())
    );
  }

  static load(id: Bytes): ProxyAdminUpdated | null {
    return changetype<ProxyAdminUpdated | null>(
      store.get("ProxyAdminUpdated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get admin(): Bytes {
    let value = this.get("admin");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set admin(value: Bytes) {
    this.set("admin", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Endowment extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Endowment entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Endowment must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Endowment", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Endowment | null {
    return changetype<Endowment | null>(store.get_in_block("Endowment", id));
  }

  static load(id: string): Endowment | null {
    return changetype<Endowment | null>(store.get("Endowment", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get endowmentType(): string {
    let value = this.get("endowmentType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowmentType(value: string) {
    this.set("endowmentType", Value.fromString(value));
  }

  get balancesLocked(): EndowmentTokenLockedLoader {
    return new EndowmentTokenLockedLoader(
      "Endowment",
      this.get("id")!.toString(),
      "balancesLocked"
    );
  }

  get balancesLiquid(): EndowmentTokenLiquidLoader {
    return new EndowmentTokenLiquidLoader(
      "Endowment",
      this.get("id")!.toString(),
      "balancesLiquid"
    );
  }

  get deposits(): EndowmentDepositTransactionLoader {
    return new EndowmentDepositTransactionLoader(
      "Endowment",
      this.get("id")!.toString(),
      "deposits"
    );
  }

  get withdrawals(): EndowmentWithdrawTransactionLoader {
    return new EndowmentWithdrawTransactionLoader(
      "Endowment",
      this.get("id")!.toString(),
      "withdrawals"
    );
  }

  get swaps(): EndowmentSwapTransactionLoader {
    return new EndowmentSwapTransactionLoader(
      "Endowment",
      this.get("id")!.toString(),
      "swaps"
    );
  }
}

export class EndowmentTokenLocked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save EndowmentTokenLocked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EndowmentTokenLocked must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EndowmentTokenLocked", id.toString(), this);
    }
  }

  static loadInBlock(id: string): EndowmentTokenLocked | null {
    return changetype<EndowmentTokenLocked | null>(
      store.get_in_block("EndowmentTokenLocked", id)
    );
  }

  static load(id: string): EndowmentTokenLocked | null {
    return changetype<EndowmentTokenLocked | null>(
      store.get("EndowmentTokenLocked", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get endowment(): string {
    let value = this.get("endowment");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowment(value: string) {
    this.set("endowment", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class EndowmentTokenLiquid extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save EndowmentTokenLiquid entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EndowmentTokenLiquid must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EndowmentTokenLiquid", id.toString(), this);
    }
  }

  static loadInBlock(id: string): EndowmentTokenLiquid | null {
    return changetype<EndowmentTokenLiquid | null>(
      store.get_in_block("EndowmentTokenLiquid", id)
    );
  }

  static load(id: string): EndowmentTokenLiquid | null {
    return changetype<EndowmentTokenLiquid | null>(
      store.get("EndowmentTokenLiquid", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get endowment(): string {
    let value = this.get("endowment");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowment(value: string) {
    this.set("endowment", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get allowanceOutstanding(): BigInt {
    let value = this.get("allowanceOutstanding");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set allowanceOutstanding(value: BigInt) {
    this.set("allowanceOutstanding", Value.fromBigInt(value));
  }

  get allowanceSpenders(): EndowmentTokenAllowanceSpenderLoader {
    return new EndowmentTokenAllowanceSpenderLoader(
      "EndowmentTokenLiquid",
      this.get("id")!.toString(),
      "allowanceSpenders"
    );
  }
}

export class EndowmentTokenAllowanceSpender extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save EndowmentTokenAllowanceSpender entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EndowmentTokenAllowanceSpender must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EndowmentTokenAllowanceSpender", id.toString(), this);
    }
  }

  static loadInBlock(id: string): EndowmentTokenAllowanceSpender | null {
    return changetype<EndowmentTokenAllowanceSpender | null>(
      store.get_in_block("EndowmentTokenAllowanceSpender", id)
    );
  }

  static load(id: string): EndowmentTokenAllowanceSpender | null {
    return changetype<EndowmentTokenAllowanceSpender | null>(
      store.get("EndowmentTokenAllowanceSpender", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class EndowmentDepositTransaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save EndowmentDepositTransaction entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EndowmentDepositTransaction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EndowmentDepositTransaction", id.toString(), this);
    }
  }

  static loadInBlock(id: string): EndowmentDepositTransaction | null {
    return changetype<EndowmentDepositTransaction | null>(
      store.get_in_block("EndowmentDepositTransaction", id)
    );
  }

  static load(id: string): EndowmentDepositTransaction | null {
    return changetype<EndowmentDepositTransaction | null>(
      store.get("EndowmentDepositTransaction", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get endowment(): string {
    let value = this.get("endowment");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowment(value: string) {
    this.set("endowment", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get amountLocked(): BigInt {
    let value = this.get("amountLocked");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountLocked(value: BigInt) {
    this.set("amountLocked", Value.fromBigInt(value));
  }

  get amountLiquid(): BigInt {
    let value = this.get("amountLiquid");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountLiquid(value: BigInt) {
    this.set("amountLiquid", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class EndowmentWithdrawTransaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save EndowmentWithdrawTransaction entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EndowmentWithdrawTransaction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EndowmentWithdrawTransaction", id.toString(), this);
    }
  }

  static loadInBlock(id: string): EndowmentWithdrawTransaction | null {
    return changetype<EndowmentWithdrawTransaction | null>(
      store.get_in_block("EndowmentWithdrawTransaction", id)
    );
  }

  static load(id: string): EndowmentWithdrawTransaction | null {
    return changetype<EndowmentWithdrawTransaction | null>(
      store.get("EndowmentWithdrawTransaction", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get endowment(): string {
    let value = this.get("endowment");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowment(value: string) {
    this.set("endowment", Value.fromString(value));
  }

  get accountType(): string {
    let value = this.get("accountType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set accountType(value: string) {
    this.set("accountType", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get beneficiaryEndowId(): i32 {
    let value = this.get("beneficiaryEndowId");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set beneficiaryEndowId(value: i32) {
    this.set("beneficiaryEndowId", Value.fromI32(value));
  }

  get beneficiaryAddr(): string | null {
    let value = this.get("beneficiaryAddr");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set beneficiaryAddr(value: string | null) {
    if (!value) {
      this.unset("beneficiaryAddr");
    } else {
      this.set("beneficiaryAddr", Value.fromString(<string>value));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class EndowmentSwapTransaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save EndowmentSwapTransaction entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EndowmentSwapTransaction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EndowmentSwapTransaction", id.toString(), this);
    }
  }

  static loadInBlock(id: string): EndowmentSwapTransaction | null {
    return changetype<EndowmentSwapTransaction | null>(
      store.get_in_block("EndowmentSwapTransaction", id)
    );
  }

  static load(id: string): EndowmentSwapTransaction | null {
    return changetype<EndowmentSwapTransaction | null>(
      store.get("EndowmentSwapTransaction", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get endowment(): string {
    let value = this.get("endowment");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set endowment(value: string) {
    this.set("endowment", Value.fromString(value));
  }

  get accountType(): string {
    let value = this.get("accountType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set accountType(value: string) {
    this.set("accountType", Value.fromString(value));
  }

  get tokenIn(): string {
    let value = this.get("tokenIn");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set tokenIn(value: string) {
    this.set("tokenIn", Value.fromString(value));
  }

  get amountIn(): BigInt {
    let value = this.get("amountIn");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountIn(value: BigInt) {
    this.set("amountIn", Value.fromBigInt(value));
  }

  get tokenOut(): string {
    let value = this.get("tokenOut");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set tokenOut(value: string) {
    this.set("tokenOut", Value.fromString(value));
  }

  get amountOut(): BigInt {
    let value = this.get("amountOut");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountOut(value: BigInt) {
    this.set("amountOut", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class MultiSigOwnerLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): MultiSigOwner[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<MultiSigOwner[]>(value);
  }
}

export class ApplicationProposalLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ApplicationProposal[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ApplicationProposal[]>(value);
  }
}

export class EndowmentTokenAllowanceSpenderLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentTokenAllowanceSpender[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentTokenAllowanceSpender[]>(value);
  }
}

export class MultiSigTransactionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): MultiSigTransaction[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<MultiSigTransaction[]>(value);
  }
}

export class TransactionConfirmationLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TransactionConfirmation[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TransactionConfirmation[]>(value);
  }
}

export class ApplicationConfirmationLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ApplicationConfirmation[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ApplicationConfirmation[]>(value);
  }
}

export class EndowmentTokenLockedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentTokenLocked[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentTokenLocked[]>(value);
  }
}

export class EndowmentTokenLiquidLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentTokenLiquid[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentTokenLiquid[]>(value);
  }
}

export class EndowmentDepositTransactionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentDepositTransaction[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentDepositTransaction[]>(value);
  }
}

export class EndowmentWithdrawTransactionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentWithdrawTransaction[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentWithdrawTransaction[]>(value);
  }
}

export class EndowmentSwapTransactionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EndowmentSwapTransaction[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EndowmentSwapTransaction[]>(value);
  }
}
